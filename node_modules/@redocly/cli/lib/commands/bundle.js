"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleBundle = void 0;
const openapi_core_1 = require("@redocly/openapi-core");
const utils_1 = require("../utils");
const perf_hooks_1 = require("perf_hooks");
const colorette_1 = require("colorette");
const fs_1 = require("fs");
function handleBundle(argv, config, version) {
    var _a, _b, _c, _d, _e;
    return __awaiter(this, void 0, void 0, function* () {
        const removeUnusedComponents = argv['remove-unused-components'] ||
            ((_c = (_b = (_a = config.rawConfig) === null || _a === void 0 ? void 0 : _a.styleguide) === null || _b === void 0 ? void 0 : _b.decorators) === null || _c === void 0 ? void 0 : _c.hasOwnProperty('remove-unused-components'));
        const apis = yield (0, utils_1.getFallbackApisOrExit)(argv.apis, config);
        const totals = { errors: 0, warnings: 0, ignored: 0 };
        const maxProblems = argv['max-problems'];
        checkForDeprecatedOptions(argv);
        for (const { path, alias } of apis) {
            try {
                const startedAt = perf_hooks_1.performance.now();
                const resolvedConfig = (0, openapi_core_1.getMergedConfig)(config, alias);
                const { styleguide } = resolvedConfig;
                styleguide.skipRules(argv['skip-rule']);
                styleguide.skipPreprocessors(argv['skip-preprocessor']);
                styleguide.skipDecorators(argv['skip-decorator']);
                if (argv.lint) {
                    (0, utils_1.checkIfRulesetExist)(styleguide.rules);
                    if (config.styleguide.recommendedFallback) {
                        process.stderr.write(`No configurations were provided -- using built in ${(0, colorette_1.blue)('recommended')} configuration by default.\n\n`);
                    }
                    const results = yield (0, openapi_core_1.lint)({
                        ref: path,
                        config: resolvedConfig,
                    });
                    const fileLintTotals = (0, openapi_core_1.getTotals)(results);
                    totals.errors += fileLintTotals.errors;
                    totals.warnings += fileLintTotals.warnings;
                    totals.ignored += fileLintTotals.ignored;
                    (0, openapi_core_1.formatProblems)(results, {
                        format: argv.format || 'codeframe',
                        totals: fileLintTotals,
                        version,
                        maxProblems: maxProblems,
                    });
                    (0, utils_1.printLintTotals)(fileLintTotals, 2);
                }
                process.stderr.write((0, colorette_1.gray)(`bundling ${path}...\n`));
                const _f = yield (0, openapi_core_1.bundle)({
                    config: resolvedConfig,
                    ref: path,
                    dereference: argv.dereferenced,
                    removeUnusedComponents,
                    keepUrlRefs: argv['keep-url-references'],
                }), { bundle: result, problems } = _f, meta = __rest(_f, ["bundle", "problems"]);
                const fileTotals = (0, openapi_core_1.getTotals)(problems);
                const { outputFile, ext } = (0, utils_1.getOutputFileName)(path, apis.length, argv.output, argv.ext);
                if (fileTotals.errors === 0 || argv.force) {
                    if (!argv.output) {
                        const output = (0, utils_1.dumpBundle)((0, utils_1.sortTopLevelKeysForOas)(result.parsed), argv.ext || 'yaml', argv.dereferenced);
                        process.stdout.write(output);
                    }
                    else {
                        const output = (0, utils_1.dumpBundle)((0, utils_1.sortTopLevelKeysForOas)(result.parsed), ext, argv.dereferenced);
                        (0, utils_1.saveBundle)(outputFile, output);
                    }
                }
                totals.errors += fileTotals.errors;
                totals.warnings += fileTotals.warnings;
                totals.ignored += fileTotals.ignored;
                (0, openapi_core_1.formatProblems)(problems, {
                    format: argv.format || 'codeframe',
                    maxProblems: maxProblems,
                    totals: fileTotals,
                    version,
                });
                if (argv.metafile) {
                    if (apis.length > 1) {
                        process.stderr.write((0, colorette_1.yellow)(`[WARNING] "--metafile" cannot be used with multiple apis. Skipping...`));
                    }
                    {
                        (0, fs_1.writeFileSync)(argv.metafile, JSON.stringify(meta), 'utf-8');
                    }
                }
                const elapsed = (0, utils_1.getExecutionTime)(startedAt);
                if (fileTotals.errors > 0) {
                    if (argv.force) {
                        process.stderr.write(`‚ùì Created a bundle for ${(0, colorette_1.blue)(path)} at ${(0, colorette_1.blue)(outputFile)} with errors ${(0, colorette_1.green)(elapsed)}.\n${(0, colorette_1.yellow)('Errors ignored because of --force')}.\n`);
                    }
                    else {
                        process.stderr.write(`‚ùå Errors encountered while bundling ${(0, colorette_1.blue)(path)}: bundle not created (use --force to ignore errors).\n`);
                    }
                }
                else {
                    process.stderr.write(`üì¶ Created a bundle for ${(0, colorette_1.blue)(path)} at ${(0, colorette_1.blue)(outputFile)} ${(0, colorette_1.green)(elapsed)}.\n`);
                }
                const removedCount = (_e = (_d = meta.visitorsData) === null || _d === void 0 ? void 0 : _d['remove-unused-components']) === null || _e === void 0 ? void 0 : _e.removedCount;
                if (removedCount) {
                    process.stderr.write((0, colorette_1.gray)(`üßπ Removed ${removedCount} unused components.\n`));
                }
            }
            catch (e) {
                (0, utils_1.handleError)(e, path);
            }
        }
        (0, utils_1.printUnusedWarnings)(config.styleguide);
        if (!(totals.errors === 0 || argv.force)) {
            throw new Error('Bundle failed.');
        }
    });
}
exports.handleBundle = handleBundle;
function checkForDeprecatedOptions(argv) {
    const deprecatedOptions = [
        'lint',
        'format',
        'skip-rule',
        'extends',
        'max-problems',
    ];
    for (const option of deprecatedOptions) {
        if (argv[option]) {
            process.stderr.write((0, colorette_1.yellow)(`[WARNING] "${option}" option is deprecated and will be removed in a future release. \n\n`));
        }
    }
}
